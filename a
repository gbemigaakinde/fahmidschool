/**
 * COMPLETE FINANCIAL SYSTEM FIX
 * Replace ALL financial functions in admin.js with these corrected versions
 * 
 * ROOT CAUSE: Fee structures are class-based (permanent), but reports were querying by session/term
 * SOLUTION: Match pupils to fees by classId only, calculate dynamically
 */

/* =====================================================
   FIX 1: OUTSTANDING FEES REPORT
   Query ALL pupils and match to class-based fee structures
===================================================== */

async function loadOutstandingFeesReport() {
    const container = document.getElementById('outstanding-fees-table');
    if (!container) return;

    const tbody = container.querySelector('tbody');
    if (!tbody) return;

    tbody.innerHTML = '<tr><td colspan="7" class="table-loading">Loading outstanding fees...</td></tr>';

    try {
        const settings = await window.getCurrentSettings();
        const session = settings.session;
        const currentTerm = settings.term;

        // ✅ Step 1: Get ALL currently enrolled pupils
        const pupilsSnap = await db.collection('pupils').get();
        
        if (pupilsSnap.empty) {
            tbody.innerHTML = '<tr><td colspan="7" style="text-align:center; color:var(--color-gray-600); padding:var(--space-2xl);">No pupils enrolled</td></tr>';
            updateSummaryDisplay(0, 0);
            return;
        }

        // ✅ Step 2: Get ALL fee structures (class-based, NO session filter)
        const feeStructuresSnap = await db.collection('fee_structures').get();
        
        const feeMap = {};
        feeStructuresSnap.forEach(doc => {
            const data = doc.data();
            // Map classId -> fee amount
            feeMap[data.classId] = data.total || 0;
        });

        if (Object.keys(feeMap).length === 0) {
            tbody.innerHTML = '<tr><td colspan="7" style="text-align:center; color:var(--color-warning); padding:var(--space-2xl);">⚠️ No fee structures configured yet</td></tr>';
            updateSummaryDisplay(0, 0);
            return;
        }

        console.log(`✓ Found ${feeStructuresSnap.size} fee structures (class-based)`);

        // ✅ Step 3: Build outstanding list by checking each pupil
        const outstandingPupils = [];
        let totalOutstanding = 0;
        const encodedSession = session.replace(/\//g, '-');

        for (const pupilDoc of pupilsSnap.docs) {
            const pupilData = pupilDoc.data();
            const pupilId = pupilDoc.id;
            const classId = pupilData.class?.id;
            
            if (!classId) {
                console.warn(`Pupil ${pupilData.name} has no classId, skipping`);
                continue;
            }
            
            const feeAmount = feeMap[classId];
            if (!feeAmount) {
                console.warn(`No fee structure for class ${classId}, skipping pupil ${pupilData.name}`);
                continue;
            }

            // Get payment record for current term
            const paymentDocId = `${pupilId}_${encodedSession}_${currentTerm}`;
            const paymentDoc = await db.collection('payments').doc(paymentDocId).get();

            let balance = feeAmount; // Default: full amount owed
            let totalPaid = 0;
            let arrears = 0;
            let status = 'owing';

            if (paymentDoc.exists) {
                const paymentData = paymentDoc.data();
                balance = Number(paymentData.balance) || 0;
                totalPaid = Number(paymentData.totalPaid) || 0;
                arrears = Number(paymentData.arrears) || 0;
                status = paymentData.status || 'owing';
            } else {
                // No payment record = owing full amount
                // Check for arrears from previous session
                const previousSession = getPreviousSessionName(session);
                if (previousSession) {
                    arrears = await calculateSessionBalance(pupilId, previousSession);
                    balance = feeAmount + arrears;
                }
            }

            // Only include pupils with outstanding balance
            if (balance > 0) {
                outstandingPupils.push({
                    name: pupilData.name || 'Unknown',
                    className: pupilData.class?.name || '-',
                    amountDue: feeAmount,
                    arrears: arrears,
                    totalDue: feeAmount + arrears,
                    totalPaid: totalPaid,
                    balance: balance,
                    status: status
                });
                
                totalOutstanding += balance;
            }
        }

        tbody.innerHTML = '';

        if (outstandingPupils.length === 0) {
            tbody.innerHTML = '<tr><td colspan="7" style="text-align:center; color:var(--color-success); padding:var(--space-2xl);">✓ All fees collected for ' + currentTerm + '!</td></tr>';
            updateSummaryDisplay(0, 0);
            return;
        }

        // Sort by balance (highest first)
        outstandingPupils.sort((a, b) => b.balance - a.balance);

        const fragment = document.createDocumentFragment();
        
        outstandingPupils.forEach(pupil => {
            const tr = document.createElement('tr');
            
            const arrearsNote = pupil.arrears > 0 
                ? `<br><span style="color:#dc3545; font-size:0.85em;">+ ₦${pupil.arrears.toLocaleString()} arrears</span>` 
                : '';
            
            tr.innerHTML = `
                <td data-label="Pupil Name">${pupil.name}</td>
                <td data-label="Class">${pupil.className}</td>
                <td data-label="Amount Due">₦${pupil.amountDue.toLocaleString()}${arrearsNote}</td>
                <td data-label="Total Paid">₦${pupil.totalPaid.toLocaleString()}</td>
                <td data-label="Balance" class="text-bold text-danger">
                    ₦${pupil.balance.toLocaleString()}
                </td>
                <td data-label="Status">
                    <span class="status-badge" style="background:${pupil.status === 'partial' ? '#ff9800' : pupil.arrears > 0 ? '#dc3545' : '#f44336'};">
                        ${pupil.status === 'partial' ? 'Partial' : pupil.arrears > 0 ? 'With Arrears' : 'Owing'}
                    </span>
                </td>
                <td data-label="Term">${currentTerm}</td>
            `;
            fragment.appendChild(tr);
        });

        tbody.appendChild(fragment);
        updateSummaryDisplay(outstandingPupils.length, totalOutstanding);

        console.log(`✓ Outstanding fees: ${outstandingPupils.length} pupils owe ₦${totalOutstanding.toLocaleString()}`);

    } catch (error) {
        console.error('❌ Error loading outstanding fees:', error);
        tbody.innerHTML = `<tr><td colspan="7" style="text-align:center; color:var(--color-danger);">Error: ${error.message}</td></tr>`;
    }
}

/* =====================================================
   FIX 2: FINANCIAL REPORTS
   Same logic: query pupils, match to class-based fees
===================================================== */

async function loadFinancialReports() {
    try {
        const settings = await window.getCurrentSettings();
        const session = settings.session;
        const currentTerm = settings.term;

        // ✅ Get ALL pupils
        const pupilsSnap = await db.collection('pupils').get();
        
        if (pupilsSnap.empty) {
            updateFinancialDisplays(0, 0, 0, 0, 0, 0, 0, session, currentTerm);
            return;
        }

        // ✅ Get ALL fee structures (class-based)
        const feeStructuresSnap = await db.collection('fee_structures').get();
        
        const feeMap = {};
        feeStructuresSnap.forEach(doc => {
            const data = doc.data();
            feeMap[data.classId] = data.total || 0;
        });

        if (Object.keys(feeMap).length === 0) {
            console.warn('No fee structures configured');
            updateFinancialDisplays(0, 0, 0, 0, 0, 0, 0, session, currentTerm);
            return;
        }

        console.log(`✓ Found ${feeStructuresSnap.size} fee structures for financial report`);

        let totalExpected = 0;
        let totalCollected = 0;
        let totalOutstanding = 0;
        let paidInFull = 0;
        let partialPayments = 0;
        let noPayment = 0;

        const encodedSession = session.replace(/\//g, '-');

        // ✅ Process each pupil
        for (const pupilDoc of pupilsSnap.docs) {
            const pupilData = pupilDoc.data();
            const pupilId = pupilDoc.id;
            const classId = pupilData.class?.id;
            
            if (!classId) continue;
            
            const feeAmount = feeMap[classId];
            if (!feeAmount) continue;

            // Get payment record
            const paymentDocId = `${pupilId}_${encodedSession}_${currentTerm}`;
            const paymentDoc = await db.collection('payments').doc(paymentDocId).get();

            let totalDue = feeAmount;
            let totalPaid = 0;
            let balance = feeAmount;
            let arrears = 0;

            if (paymentDoc.exists) {
                const data = paymentDoc.data();
                arrears = Number(data.arrears) || 0;
                totalDue = feeAmount + arrears;
                totalPaid = Number(data.totalPaid) || 0;
                balance = Number(data.balance) || 0;
            } else {
                // No payment record - check for arrears
                const previousSession = getPreviousSessionName(session);
                if (previousSession) {
                    arrears = await calculateSessionBalance(pupilId, previousSession);
                    totalDue = feeAmount + arrears;
                    balance = totalDue;
                }
            }

            totalExpected += totalDue;
            totalCollected += totalPaid;
            totalOutstanding += balance;

            // Categorize payment status
            if (balance === 0 && totalPaid > 0) {
                paidInFull++;
            } else if (totalPaid > 0 && balance > 0) {
                partialPayments++;
            } else {
                noPayment++;
            }
        }

        const collectionRate = totalExpected > 0
            ? ((totalCollected / totalExpected) * 100).toFixed(1)
            : 0;

        updateFinancialDisplays(
            totalExpected,
            totalCollected,
            totalOutstanding,
            collectionRate,
            paidInFull,
            partialPayments,
            noPayment,
            session,
            currentTerm
        );

        console.log(`✓ Financial report generated:`);
        console.log(`  - Expected: ₦${totalExpected.toLocaleString()}`);
        console.log(`  - Collected: ₦${totalCollected.toLocaleString()}`);
        console.log(`  - Outstanding: ₦${totalOutstanding.toLocaleString()}`);
        console.log(`  - Collection rate: ${collectionRate}%`);

    } catch (error) {
        console.error('❌ Error loading financial reports:', error);
        window.showToast?.('Failed to load financial reports', 'danger');
    }
}

/* =====================================================
   FIX 3: CSV EXPORT
   Same pupil-based approach
===================================================== */

async function exportFinancialCSV(session, term) {
    try {
        window.showToast?.('Preparing CSV export...', 'info', 2000);

        // ✅ Get ALL pupils
        const pupilsSnap = await db.collection('pupils').get();
        
        if (pupilsSnap.empty) {
            window.showToast?.('No pupils found', 'warning');
            return;
        }

        // ✅ Get ALL fee structures
        const feeStructuresSnap = await db.collection('fee_structures').get();
        
        const feeMap = {};
        feeStructuresSnap.forEach(doc => {
            const data = doc.data();
            feeMap[data.classId] = data.total || 0;
        });

        if (Object.keys(feeMap).length === 0) {
            window.showToast?.('No fee structures configured', 'warning');
            return;
        }

        const reportData = [];
        const encodedSession = session.replace(/\//g, '-');

        for (const pupilDoc of pupilsSnap.docs) {
            const pupilData = pupilDoc.data();
            const pupilId = pupilDoc.id;
            const classId = pupilData.class?.id;
            
            if (!classId) continue;
            
            const feeAmount = feeMap[classId];
            if (!feeAmount) continue;

            const paymentDocId = `${pupilId}_${encodedSession}_${term}`;
            const paymentDoc = await db.collection('payments').doc(paymentDocId).get();

            let totalDue = feeAmount;
            let totalPaid = 0;
            let balance = feeAmount;
            let arrears = 0;
            let status = 'owing';

            if (paymentDoc.exists) {
                const data = paymentDoc.data();
                arrears = Number(data.arrears) || 0;
                totalDue = feeAmount + arrears;
                totalPaid = Number(data.totalPaid) || 0;
                balance = Number(data.balance) || 0;
                status = data.status || 'owing';
            } else {
                const previousSession = getPreviousSessionName(session);
                if (previousSession) {
                    arrears = await calculateSessionBalance(pupilId, previousSession);
                    totalDue = feeAmount + arrears;
                    balance = totalDue;
                }
            }

            reportData.push({
                pupilName: pupilData.name || 'Unknown',
                className: pupilData.class?.name || '-',
                amountDue: feeAmount,
                arrears: arrears,
                totalDue: totalDue,
                totalPaid: totalPaid,
                balance: balance,
                status: status
            });
        }

        if (reportData.length === 0) {
            window.showToast?.('No pupils with fee structures for this term', 'warning');
            return;
        }

        // Create CSV
        const headers = ['Pupil Name', 'Class', 'Term Fee', 'Arrears', 'Total Due', 'Total Paid', 'Balance', 'Status'];
        const csvRows = [headers.join(',')];
        
        reportData.forEach(p => {
            csvRows.push([
                `"${(p.pupilName || '').replace(/"/g, '""')}"`,
                `"${(p.className || '').replace(/"/g, '""')}"`,
                p.amountDue,
                p.arrears,
                p.totalDue,
                p.totalPaid,
                p.balance,
                `"${p.status}"`
            ].join(','));
        });

        // Add summary
        const totalExpected = reportData.reduce((sum, p) => sum + p.totalDue, 0);
        const totalCollected = reportData.reduce((sum, p) => sum + p.totalPaid, 0);
        const totalOutstanding = reportData.reduce((sum, p) => sum + p.balance, 0);
        const collectionRate = totalExpected > 0 ? ((totalCollected / totalExpected) * 100).toFixed(1) : 0;

        csvRows.push([]);
        csvRows.push(['SUMMARY','','','','','','','']);
        csvRows.push(['Total Expected', '', '', '', totalExpected, '', '', '']);
        csvRows.push(['Total Collected', '', '', '', totalCollected, '', '', '']);
        csvRows.push(['Total Outstanding', '', '', '', totalOutstanding, '', '', '']);
        csvRows.push(['Collection Rate', '', '', '', collectionRate + '%', '', '', '']);

        const csvContent = csvRows.join('\n');
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `Financial_Report_${session.replace(/\//g, '-')}_${term}_${new Date().toISOString().split('T')[0]}.csv`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        window.URL.revokeObjectURL(url);

        window.showToast?.(`✓ CSV exported: ${reportData.length} pupils`, 'success');

    } catch (error) {
        console.error('❌ Error exporting CSV:', error);
        window.showToast?.('Failed to export CSV', 'danger');
    }
}

/* =====================================================
   FIX 4: PDF EXPORT
   Same pupil-based approach
===================================================== */

async function exportFinancialPDF(session, term) {
    try {
        if (typeof window.jspdf === 'undefined') {
            window.showToast?.('PDF library not loaded. Please refresh.', 'danger');
            return;
        }

        window.showToast?.('Preparing PDF export...', 'info', 2000);

        // ✅ Get ALL pupils and fees (same logic as CSV)
        const pupilsSnap = await db.collection('pupils').get();
        
        if (pupilsSnap.empty) {
            window.showToast?.('No pupils found', 'warning');
            return;
        }

        const feeStructuresSnap = await db.collection('fee_structures').get();
        
        const feeMap = {};
        feeStructuresSnap.forEach(doc => {
            const data = doc.data();
            feeMap[data.classId] = data.total || 0;
        });

        if (Object.keys(feeMap).length === 0) {
            window.showToast?.('No fee structures configured', 'warning');
            return;
        }

        const reportData = [];
        const encodedSession = session.replace(/\//g, '-');

        for (const pupilDoc of pupilsSnap.docs) {
            const pupilData = pupilDoc.data();
            const pupilId = pupilDoc.id;
            const classId = pupilData.class?.id;
            
            if (!classId) continue;
            
            const feeAmount = feeMap[classId];
            if (!feeAmount) continue;

            const paymentDocId = `${pupilId}_${encodedSession}_${term}`;
            const paymentDoc = await db.collection('payments').doc(paymentDocId).get();

            let totalDue = feeAmount;
            let totalPaid = 0;
            let balance = feeAmount;
            let status = 'owing';

            if (paymentDoc.exists) {
                const data = paymentDoc.data();
                const arrears = Number(data.arrears) || 0;
                totalDue = feeAmount + arrears;
                totalPaid = Number(data.totalPaid) || 0;
                balance = Number(data.balance) || 0;
                status = data.status || 'owing';
            }

            reportData.push({
                pupilName: pupilData.name || 'Unknown',
                className: pupilData.class?.name || '-',
                amountDue: `₦${feeAmount.toLocaleString()}`,
                totalPaid: `₦${totalPaid.toLocaleString()}`,
                balance: `₦${balance.toLocaleString()}`,
                status: status.charAt(0).toUpperCase() + status.slice(1)
            });
        }

        if (reportData.length === 0) {
            window.showToast?.('No pupils with fee structures for this term', 'warning');
            return;
        }

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();

        // Header
        doc.setFontSize(18);
        doc.text('FAHMID NURSERY & PRIMARY SCHOOL', 105, 15, { align: 'center' });
        
        doc.setFontSize(14);
        doc.text('Financial Report', 105, 25, { align: 'center' });
        
        doc.setFontSize(10);
        doc.text(`Session: ${session} | Term: ${term}`, 105, 32, { align: 'center' });
        doc.text(`Generated: ${new Date().toLocaleDateString('en-GB')}`, 105, 38, { align: 'center' });

        // Table
        const tableData = reportData.map(p => [
            p.pupilName,
            p.className,
            p.amountDue,
            p.totalPaid,
            p.balance,
            p.status
        ]);

        doc.autoTable({
            startY: 45,
            head: [['Pupil Name', 'Class', 'Amount Due', 'Paid', 'Balance', 'Status']],
            body: tableData,
            theme: 'grid',
            styles: { fontSize: 8 },
            headStyles: { fillColor: [0, 178, 255] }
        });

        // Summary
        const totalExpected = reportData.reduce((sum, p) => sum + parseFloat(p.amountDue.replace(/[₦,]/g, '')), 0);
        const totalCollected = reportData.reduce((sum, p) => sum + parseFloat(p.totalPaid.replace(/[₦,]/g, '')), 0);
        const totalOutstanding = reportData.reduce((sum, p) => sum + parseFloat(p.balance.replace(/[₦,]/g, '')), 0);
        const collectionRate = totalExpected > 0 ? ((totalCollected / totalExpected) * 100).toFixed(1) : 0;

        const finalY = doc.lastAutoTable.finalY + 12;
        
        doc.setFontSize(12);
        doc.text('Summary', 14, finalY);
        
        doc.setFontSize(10);
        doc.text(`Total Expected:     ₦${totalExpected.toLocaleString()}`, 14, finalY + 8);
        doc.text(`Total Collected:    ₦${totalCollected.toLocaleString()}`, 14, finalY + 14);
        doc.text(`Total Outstanding:  ₦${totalOutstanding.toLocaleString()}`, 14, finalY + 20);
        doc.text(`Collection Rate:    ${collectionRate}%`, 14, finalY + 26);

        doc.save(`Financial_Report_${session.replace(/\//g, '-')}_${term}_${new Date().toISOString().split('T')[0]}.pdf`);
        
        window.showToast?.(`✓ PDF exported: ${reportData.length} pupils`, 'success');

    } catch (error) {
        console.error('❌ Error exporting PDF:', error);
        window.showToast?.('Failed to export PDF', 'danger');
    }
}

/* =====================================================
   FIX 5: EXPORT WRAPPER FUNCTION
===================================================== */

async function exportFinancialReport(format) {
    if (format !== 'csv' && format !== 'pdf') {
        window.showToast?.('Invalid export format', 'warning');
        return;
    }

    try {
        const settings = await window.getCurrentSettings();
        const session = settings.session;
        const term = settings.term;

        if (format === 'csv') {
            await exportFinancialCSV(session, term);
        } else {
            await exportFinancialPDF(session, term);
        }

    } catch (error) {
        console.error('❌ Error exporting financial report:', error);
        window.handleError?.(error, 'Failed to export report');
    }
}

/* =====================================================
   HELPER FUNCTIONS (keep existing ones)
===================================================== */

function getPreviousSessionName(currentSession) {
    const match = currentSession.match(/(\d{4})\/(\d{4})/);
    if (!match) return null;
    
    const startYear = parseInt(match[1]);
    const endYear = parseInt(match[2]);
    
    return `${startYear - 1}/${endYear - 1}`;
}

async function calculateSessionBalance(pupilId, session) {
    try {
        const paymentsSnap = await db.collection('payments')
            .where('pupilId', '==', pupilId)
            .where('session', '==', session)
            .get();
        
        let totalBalance = 0;
        
        paymentsSnap.forEach(doc => {
            const data = doc.data();
            totalBalance += Number(data.balance) || 0;
        });
        
        return totalBalance;
        
    } catch (error) {
        console.error('Error calculating session balance:', error);
        return 0;
    }
}

function updateFinancialDisplays(
    totalExpected,
    totalCollected,
    totalOutstanding,
    collectionRate,
    paidInFull,
    partialPayments,
    noPayment,
    session,
    term
) {
    const expectedEl = document.getElementById('report-total-expected');
    const collectedEl = document.getElementById('report-total-collected');
    const outstandingEl = document.getElementById('report-total-outstanding');
    const rateEl = document.getElementById('report-collection-rate');
    
    if (expectedEl) expectedEl.textContent = `₦${Number(totalExpected).toLocaleString()}`;
    if (collectedEl) collectedEl.textContent = `₦${Number(totalCollected).toLocaleString()}`;
    if (outstandingEl) outstandingEl.textContent = `₦${Number(totalOutstanding).toLocaleString()}`;
    if (rateEl) rateEl.textContent = `${collectionRate}%`;
    
    const paidFullEl = document.getElementById('report-paid-full');
    if (paidFullEl) paidFullEl.textContent = paidInFull;
    
    const partialEl = document.getElementById('report-partial');
    if (partialEl) partialEl.textContent = partialPayments;
    
    const owingEl = document.getElementById('report-owing');
    if (owingEl) owingEl.textContent = noPayment;
    
    const sessionEl = document.getElementById('report-session-display');
    if (sessionEl) sessionEl.textContent = session || '—';
    
    const termEl = document.getElementById('report-term-display');
    if (termEl) termEl.textContent = term || '—';
}

function updateSummaryDisplay(count, total) {
    const countEl = document.getElementById('outstanding-count');
    const totalEl = document.getElementById('outstanding-total');
    
    if (countEl) countEl.textContent = count;
    if (totalEl) totalEl.textContent = `₦${total.toLocaleString()}`;
}

// ✅ Make all functions globally available
window.loadOutstandingFeesReport = loadOutstandingFeesReport;
window.loadFinancialReports = loadFinancialReports;
window.exportFinancialReport = exportFinancialReport;
window.exportFinancialCSV = exportFinancialCSV;
window.exportFinancialPDF = exportFinancialPDF;
window.getPreviousSessionName = getPreviousSessionName;
window.calculateSessionBalance = calculateSessionBalance;
window.updateFinancialDisplays = updateFinancialDisplays;
window.updateSummaryDisplay = updateSummaryDisplay;

console.log('✅ COMPLETE FINANCIAL SYSTEM FIX LOADED');
console.log('   - Outstanding fees: Pupil-based with class fee matching');
console.log('   - Financial reports: Pupil-based with class fee matching');
console.log('   - CSV export: Pupil-based with class fee matching');
console.log('   - PDF export: Pupil-based with class fee matching');